=The new type pattern is used to statically enforce that values should never be confused
and indicate the units of a value
=It can also be used to abstract away some implementation details of a type: The new type can expose a public
API that is different from the API of a private inner type
=New type can also hide internal implementation
=It is also lightweight way to achieve encapsulation to hide implementation details

Creating Type Synonyms with Type Aliases
Rust provides one the ability to declare a type alias to give an existing type another name
*type Kilometers = i32;

=Now the alias Kilometers is a Synonym for i32; unlike Millimetres and Meter types that are
created
Kilometres is not a separate, new type. Values that have the type Kilometers will be treated the same as
values of type i32

fn main(){
   type Kilometers = i32;
    let x = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
}
=Because kilometers and i32 are of the same type, we can add values of both types and the Kilometer values can be passed
to functions that take i32 parameters type
However, using this method does not provide type-checking benefits that we get from the new type pattern
If we mix up Kilometers and i32 values somewhere, the complier does not give one an error

The main use case of type synonyms is to reduce repetition
*Box<dyn Fn() + Send + 'static>
Writing this lengthly type in function signatures and as type annotations all over the code can be tiresome
and error prone

let f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!("rust"));

fn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {
  // --snip
}
fn returns_long_type() -> Box<dyn Fn() + Send + 'static>){
// --snip
}

A type alias makes the code more manageable by reducing repetition
An alias named thunk for a verbose Type and can replace all uses of the type with the shorter Alias Thunk

type Thunk = Box<dyn Fn() + Send + 'static>;
let f: Thunk = Box::new(|| println!("rust"));

fn takes long_type(f: Thunk) {
  // --snip
}
fn returns long_type(f: Thunk) {
  // --snip
}
NOTE: Choosing a meaningful name for a type alias can help communicate one's intent as well(thunk is a word for code to be evaluated at a later time)
so it is an appropriate name for a closure that gets stored
=Type aliases are also commonly used with Result<T, E> type for reducing repetition
The std::io module in the standard library I/O Operations often return a Result<T, E> to handle situations
when operations fail to work. This library has a std::io::Error struct that represents  all possible
I/O errors
Many of the functions in std::io  will be returning Result<T, E> where E is the std::io::Error, such as these functions in the Write
trait

use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&mut self, buf: &[u8])-> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u38]) -> Result<(), Error>;
    fn write_mut(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}

The Result<..., Error> is repeated, As such std::io has this type alias declaration
type Result<T> = std::result::Result<T, std::io::Error>;

Because this declaration, is in the std::io module, we can use the fully qualified alias std::io::Result<T>
that is Result<T, E> with the E filled in std::io::Error
The write trait function signature:
pub trait Write {
fn write(&mut self, buf: &[u8]) -> Result<usize>;
fn flush(&mut self)-> Result<()>;

fn write_all(&mut self, buf: &[u8]) -> Result<()>;
fn write_fmt(&mut self, fmt : fmt::Arguments) -> Result<()>;

The type alias helps in two ways:
It makes code easier to write
It gives a consistent interface across all of std::io Because it is an alias, it is just another
Result<T, E> which means one can use methods that work on Result<T, E> with it, as well as the special syntax like
? operator

The Never Type that Never Returns
=Rust has a special type named ! that is known in type theory lingo as  the empty type
because it has no values. It is preferred to be called the never type because it stands in place of the
return type when a function will never return

fn name() -> ! { //function name returns never
   // --snip--
}
=Functions that return never are called diverging functions. We can't create values of the type ! so name can never possibly
return
Expressions of type ! can be coerced into any other type
=The never type is useful with the panic! macro as well. The unwrap function that is called on Option<T> values to produce a value
or panic with this definition

------------------------------------------------------------------------------------------------------------------------
A match with an arm that ends in continue
let output: u32 = match guess.trim().parse() {
  Ok(num) => num,
  Err(_) =>continue,
};

continue has a ! value. That is when Rust computes the type of guess it looks at both the match arms, the former with a value
of u32 and the latter with a ! value. Because the ! can never have a value, Rust decides that the type of guess is u32
continue does not return a value
--------------------------------------------------------------------------------------------------------------------------
impl <T> Option<T> {
   pub fn unwrap(self) -> T {
   match self {
     Some(val) => val;
     None => panic!("called `Option:unwrap()` on a `None` value"),
     }
  }
}
In this code, the same thing happens as in the match. Rust sees that val has the Type T and panic!
has the type !, so the result of the overall match expression is T
The code works because panic! does not produce a value; it ends the program. In the None case
we do not return a value from the Unwrap, so the code is valid

Final Expression that has the ! type is a loop
println!("forever");

loop {
  println!("and ever ");
}
=Here the loop never ends so ! is the value of the expression. However this is not true if a break is included in the loop
because the loop terminates when it gets to the break

Dynamically Sized Types and the Sized Trait
=Rust needs to know certain details about its types, such as how much space to allocate for a value of a particular type
This leaves one corner of its type system
=They are also referred to as DSTs or unsized types, these types allow one to write code using values
whose size can only be known at runtime
=str is a Dynamically Sized Type, we cannot know how long the string is until runtime
,meaning we cannot create a variable of type str, nor can we take an argument of type str
Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type
must use the same amount of memory
=It is not possible to create a variable holding a dynamically sized type

let s1: str = "Hello, there!"; //needs 12 bytes of storage
let s2: str = "How's it going?"; //needs 15 bytes of storage

To fix the error, s1 and s2 types should be a &str rather than str
*The slice data structure stores the starting position and the length of the slice
*So, although &T is a single value that stores the memory address of where T is allocated, a &str is two values
the address of the str and its length. As such the size of the &str  value can be known at compile time
It is twice the length of a usize. The size of &str is always known, In general, this is the way in which dynamically sized types
are used in Rust: they have an extra bit of metadata that stores the size of dynamic information
The golden rule of dynamically sized types is that the values must always be put behind a pointer of some kind
One can combine str with all kinds of pointers Box<str> or Rc<str>
Every trait is dynamically sized type we can refer to  by using the name of the trait. To use traits as trait objects
they must be put behind a pointer such as:
&dyn Trait, Box<dyn Trait> (Rc<dyn Trait>)

To work with Dynamically sized Traits Rust provides the Sized trait to determine whether or not a type's size is known at compile
time
This trait is automatically implemented for everything whose size is known at compile time
In addition, Rust adds a bound on Sized to every generic function implicitly, That is a generic function definition like;

fn generic<T>(t: T){
   //--snip--
}
is actually treated as though this has been written:

fn generic<T: sized>(t: T) {
  //--snip--
}
By default, generic functions will work only on types that have a known size at compile time
However, this special syntax can be used to relax the restriction:
fn generic<T: ?sized>(t: &T) {
  //--snip--
}

A trait bound on ?sized means "T may or may not be sized" and this notation overrides the default that
generic types must have a known size at compile time. The ?Trait syntax with this meaning  is only available for Sized, not
any other traits
The type of parameter t is switched from T to &T. Because the type might not be sized, it needs to be used behind some
kind of pointer, in this a reference has been used
