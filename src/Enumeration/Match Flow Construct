-Rust has an Extremely powerful control flow construct called Match that allows one to compare values
against  a series of patterns and then execute code  based on which patterns match
-Patterns can be made of literal values, variable names, wildcards
Values go through each pattern in a match, and the first pattern the value "fits"
the value falls into the associated code block used during execution

Match Constructs
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*enum Coin {
     Penny,
     Nickel,
     Dime,
     Quarter,
 }

 fn value_in_cents(coin : Coin) -> u8 {
     match coin { //match expression
         //the type of coin is the enum Coin
         //the match arm; an arm has two parts: a pattern and code
         Coin::Penny => 1, //(pattern)Value:: Value => 1(code)
         Coin::Nickel => 5,
         Coin::Dime => 10,
         Coin::Quarter => 25,
         //when the match expression executes, it compares the resultant value against the pattern of each arm in order
         //If a pattern matches the value, the code associated with that pattern gets executed
         //the code associated with each arm is an expression, and the resultant value of the expression is the value that gets returned from the entire match expression
     }
 }

 fn main(){
     value_in_cents(Coin::Quarter(UsState::Alaska), Coin::Penny);
        println!("The value in cents for the coins are: {}", value_in_cents(Coin::Dime, Coin::Penny));

 }
------------------------------------------------------------------------------------------------------------------------

Matches in rust are exhaustive, every last possibility must be exhausted in order for the code to be valid
