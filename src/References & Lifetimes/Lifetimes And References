-A lifetime is a named, symbolic representation of the scope during which a reference is valid
-Lifetimes ensure that references are valid as long as they are required
-Every Reference in Rust has a lifetime, which is the scope for which the reference is valid
Lifetimes are implicit and inferred. They have to be annotated when the lifetime of references could be
related in a few different ways
-Rust requires  one to annotate the relationships using generic lifetime parameters to ensure that actual
references used at runtime will definitely be valid

Preventing Dangling references with Lifetimes
-The main aim of lifetimes is to prevent dangling references, which causes a program to reference data other than
the data it is intended to reference

Dangling reference
fn main(){ //outer scope -start
   let r;

    { //inner scope start
     let x = 100;
     r = &x;
     } //inner scope end
    println!("r: {r}");
} //outer scope end
//The outer scope declares a variable r with no initial value, and the inner scope declares a variable named
x with an initial value of 100
Inside the inner scope, the value of r is set as a reference to x(&x). Then the inner scope ends, and attempt to print the
value of r
//The code fails to compile since the value that r references to is already out of scope before trying to use it

NOTE: x will be already out of scope when the inner scope ends
but r is still valid for the outer scope, because its scope is larger("lives longer")
NOTE: r references to  a memory that is already deallocated(freed) when x is out of the inner scope

Borrow checker
-The rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid

fn main(){ //outer scope -start
   let r; --------------------------------------------------- 'a

    { //inner scope start
     let x = 100; ---------------------------------------------'b
     r = &x;
     } //inner scope end
    println!("r: {r}");
} //outer scope end

-the lifetime of r is annotated with 'a and the lifetime of x with 'b
//The inner block b is much smaller than the outer 'a lifetime block
-At compile time, rust compares the size of two lifetimes and sees that r has a lifetime of 'a but that it refers to memory
with a lifetime of 'b. The program is rejected since 'b is shorter than 'a
The subject of the reference does not live long as the reference


No dangling Reference
fn main(){ //scope of both 'b and 'a
  let x = 100; ------------------------------ 'b(larger scope)

  let r = &x; --------------------------------'a

  println!("r: {r}");
}

x has a lifetime of 'b which in this case is larger than 'a
Therefore r can reference x because Rust knows that the reference of r will always be valid
so long x is valid

Generic Lifetimes in Functions
//a function that returns the longest string slice
fn main(){
  let string1 = String::from("Rust");
  let string2 = "xyz";

  let result = longest(string1.as_str(), string2);
  println!("The longest string is {result}");
}

//the function takes string slices which are references rather than Strings since the longest function should
not take ownership of its parameters

fn longest(x: &str, y:&str) -> &str{
if x.len() > y.len() {
   x
}
else {
 y
}

//an error is generated: (this function's return type contains a borrowed value, but the signature does not help)

-The return type of the function requires a generic lifetime parameter on it because Rust can't tell whether the reference
being returned refers to x or y, since the if block in the body of the function returns a reference to x and the else block
returns a reference to y

-The concrete lifetimes of the references passed in is unknown together with the concrete values passed into the function as well as
if whether the if case or else case will execute
-The borrow checker is unable to determine the lifetime of x and y relate to the lifetime of the return values
-The generic lifetime parameters, define the relationship between the references so the borrow checker is able
to perform its analysis

Lifetime Annotation Syntax
Lifetime annotations do not change how long any of the references live, Rather they describe the relationships of the lifetimes of
multiple references to each other without affecting their lifetimes
Since functions can accept any type when the signature specifies a generic type parameter, functions can accept references
with any lifetime by specifying a generic lifetime parameter

Lifetime annotations have a syntax where, the name of the lifetime parameters must start with an apostrophe(') and are usually all lowercase
and short like generic types
Lifetime parameter annotations are placed after the & of a reference using a space to separate the annotation from the reference type

i.e
&i32 //a reference
& 'a i32 //a reference with an explicit(done by the programmer manually) lifetime
& 'a mut i32 //a mutable reference with an explicit lifetime

NOTE: Annotations are meant to tell the Rust compiler how generic lifetime parameters of multiple references relate to each other

------------------------------------------------------------------------------------------------------------------------
Lifetime annotations in function Signatures
-To use lifetime annotations in function signatures, one needs to declare the generic lifetime parameters
inside angle brackets between the function name and the parameter list
-The signature will express the following constraint; the returned reference will be valid as long as both the parameters
are valid/ This is the relationship between the lifetimes of the parameters and the return value

fn name<'a>(x : &'a str, y: &'a str) ->  &'a str {
 if x.len() > y.len() {x } else {y}

 The function signature tells rust that for some lifetime 'a, the function takes two parameters both of which are string slices
 that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function
 will live at least as long as the lifetime 'a.
 Therefore, the lifetime of the reference returned by the function is the same as the smaller of the lifetimes
 of the values referred by the function arguments
 -The Borrow checker should reject values that do not adhere to the constraints
 The function should note that some scope can be substituted for 'a that satisfies the signature

 When annotating lifetimes in functions the annotations go into the function signature not in the function body
 The lifetime annotation become part of the contract of the function, much like types in the signature
 When one passes concrete references to the function, the concrete lifetime that is substituted  for 'a is the part of the scope of x
 that overlaps with the scope of y
 The generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y since one has annotated
 the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length
 of the smaller of the lifetimes of x and y

 fn main(){ //outer scope
  let string1 = String::from("Rust programming language");
  { //inner scope
   let string2 = String::from("xyz");
   let result = longest(string1.as_str(), string2.as_str());
   println!("The longest string is {result}");
  }
}

NOTE:
I) string1 is valid until the end of the outer scope
II)string2 is valid until the end of the inner scope
III)Result references something that is valid until the end of the inner scope
*The borrow checker approves the code

IV)The lifetime of results must be a smaller lifetimes of the two arguments

NOTE:
-The way in which lifetime parameters are specified depends on the role of the function
//this function returns the first parameter
fn name<'a>(x: &'a str, y: &str) -> &'a str{ //the lifetime of y does not need to be specified since  it has no relationship with the lifetime of x


}
-When returning a reference from the function, the lifetime parameter for the return type needs to match the lifetime of the parameter
for one of the parameters
If the reference returned does not refer to one of the parameters, it must refer to a value created within this function
However, this is a dangling reference because the value will go out of scope at the end of the function
NOTE: Ultimately, the lifetime syntax is about connecting the lifetimes of various parameters and return values of functions
Once they are connected Rust has enough information to allow memory safe operations and disallow operations that would create dangling pointers or
otherwise violate memory safety
------------------------------------------------------------------------------------------------------------------------------


Lifetime Annotation in Struct Definitions
-One can define structs that hold references but lifetime annotations will be required on every reference
in the struct definition

------------------------------------------------------------------------------------------------------------------------------
Lifetime Elision
-Lifetimes on functions or method parameters are called input lifetimes, and lifetimes of return values are called output
lifetimes
-Lifetime elision rules refer to patterns programmed into Rust analysis of references
The compiler uses three rules to figure out the lifetimes of the references when there are no explicit annotations
-The first rule applies to input lifetimes, and the second and third rules apply to the output lifetimes
The rules apply to the fn definitions as well as impl blocks

*Compiler rules
-The first rule is that the compiler assigns a lifetime parameter to each parameter that is a reference
A function with one parameter gets one lifetime parameter * fn name<'a>(x : &'a i32)
a function with two parameters gets two separate lifetime parameters
* fn name<'a>(x: &'a i32, y: &'a i32)

-The second rule is that, if there is exactly one input lifetime parameter, that lifetime is assigned to all
output lifetime parameters
fn name<'a>(x: &'a i32) -> &'a i32

-The third rule is that, if there are multiple input lifetime parameters, but one of them is &self
or &mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters

------------------------------------------------------------------------------------------------------------------------

Lifetime Annotation in method definitions
-When one implements methods on a struct with lifetimes, we use the same syntax as that of the generic type
parameters
When one declares and uses the lifetime parameters depends on whether they are related to the struct fields or the method
parameters and return values
Lifetimes names for struct fields always need to be declared after the impl keyword and then used after the struct
name because those lifetimes are part of the struct  type
In method signatures inside the impl block, references might be tied to the lifetime of references
in the structs field, or they might be independent

impl <'a> ImportantExcerpt<'a>{
 fn level(&self) -> i32 {
 3
 }
}
-The lifetime parameter declaration after impl and its use after the type name are required,
but we are not required to annotate the lifetime of the reference to self because of the first elision rule

third elision rule

*impl <'a> ImportantExcerpt<'a>{
 fn announce_and_return_part(&self, announcement: &str) ->&str{
  println!("{announcement}");
  self.part
  }
}
There are two input lifetimes, So rust applies the first lifetime elision rule and give &self
and announcement their own lifetimes
Since one of the parameters is &self, the return type  gets the lifetime of &self

Static Lifetime
-'static denotes that the affected reference can live for the entire duration of the program
-All String literals have the 'static lifetime annotated as:
let s: &'static str = "Static lifetime"
The text of the string is directly stored  in the program binary
-The lifetime of all string literals is always static
