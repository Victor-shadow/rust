-A slice is a pointer to a block of memory
They can be used to access portions of data stored in contiguous memory blocks
It can be used with data structures like arrays, vectors, strings
Slices use index numbers to access portions of data. The size of a slice is determined at runtime

Slices are pointers to actual data. They are passed as references to functions, which is known as
borrowing
-Slices allow one to reference a contiguous sequence of elements in a collection
It is a reference , so it does not have ownership

Syntax: let sliced_value = &data_structure[start_index..end_index]

The minimum index value is 0 and the maximum index value is the size of the data structure
NOTE: The end index is not included in the data Structure

Mutable Slices
-the &mut keyword is used to make a slice mutable



String Slices
-A string slice is a reference to the contiguous sequence of elements in a String
-Slices are created using a range within square brackets by specify [starting_index..ending_index] where
starting_index is the first position in the slice and ending_index is one more than the last position in the slice
Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to the ending
index minus the starting index
*let s = String::from("hello world");
let hello = &s[0..5]; //rust is a reference(&s) to a portion of a String specified
let world = &s[6..11]; //a pointer to the byte at index 6 of s with a length of value 5

With Rust range syntax. if one wants to start at index 0, one can drop  the value between the two periods
since they are equal
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];

By the same token, if the slice includes the last byte of the string, one can drop the trailing number
That means they are equal

let s = String::from("hello");
let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];

//one can also drop both values to take a slice of the entire string; so these are equal

let s = String::from("hello");

let len = s.len();
let slice = &s[0..len];
let slice = &s[..];

//NOTE: String slice range indices must occur at  a valid UTF-8 character boundaries
If one attempts to create a string slice in the middle of a multi-byte character, the program exits with an error
NOTE: In idiomatic rust functions do not take ownership of their arguments unless they need to


fn main(){
  let mut s = String::from("hello world");

  let word = first_word(&s);
  s.clear()//error! //index to the end of the first word is invalid since the string is cleared
  println!("the first word is: {word}")
}

String literals as Slices
-String literals are stored inside the binary
*let s = "Hello world";
//the type of s here is a &str
//it is a slice pointing to that specific point in binary
//String literals are also immutable
&str is an immutable reference

String Slices as parameters
if one has a String slice it can be passed directly to a function as a slice or a reference to the String

General string slices
*let a = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000];
let slice = &a[1..5];
assert_eq!(slice, &[2, 3]);
//the slice has a type i32

-string slices store a reference to the first element and a length

CODE:
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole.
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s.
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or
    // whole.
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
