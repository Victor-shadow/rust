-The two most used string types in Rust are
 String - String Object
 &str - String Literal

String Literal
:String literal(&str) is used when the value of a string is known at runtime
String literals are a set of characters, which are hardcoded into variables
They are found in a module std::str
They are also known as string slices
String Literals are static by default
The String literals are guaranteed to be valid for the duration of the entire program


String Object
-The String Object is provided in Standard Library
A String is a growable collection. It is mutable and UTF-8 encoded type
The String object type can be used to represent String values that are provided at Runtime
String object is allocated at the heap

To create a String object use:
i)String::new()
//creates an empty String
ii)String::from()
//This creates a String with some default value passed as a parameter to the from() method

-A string is stored as a vector of bytes(Vec<u8>) but guaranteed to always be a valid UTF-8
sequence
-String is heap allocated, growable and not null terminated
-A string stores its data on the heap
&str is a slice(&[u8]) that always points to a valid UTF-8 sequence and can be used
to view into a string

Methods of a String Object
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Method                       Signature                                                               Description
new()                        pub const fn new() -> String                                            Creates a new empty String

to_string()                  fn to_string(&self) -> String                                           Converts the given value to
                                                                                                     a String

replace()                    pub fn replace<'a P>(&'a self, from: P,  to:str) -> String              Replaces all matches of a pattern
                                                                                                     with another string

as_str()                     pub fn as_str(&self) -> &str                                            Extracts a String slice containing
                                                                                                     the entire String

push()                       pub fn push(&mut self, ch:char)                                         Appends the given character to the end
                                                                                                     of the given String

push_str()                   pub fn push_str(&mut self, string: &str)                                Appends a given string slice onto the end
                                                                                                     of the given String

len()                        pub fn len(&self) -> usize                                              Returns the length of the String in bytes

trim()                       pub fn trim(&self) -> &str                                              Returns a String slice with leading and trailing whitespace
                                                                                                     removed

split_whitespace             pub fn split_whitespace(&self) -> SplitWhitespace                       Splits a string slice by whitespace and returns an Iterator


split()                      pub fn split<'a P>(&'a self, pat: P) -> Split <'a P>                    Returns an Iterator over substrings of this string slice, separated by
                             where P is a pattern can be &str,char or a closure that                 characters matched by a pattern
                             determines the split
chars()                      pub fn chars(&self) -> Chars                                            Returns an Iterator over the chars  of a String slice
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

String Operations

String
-Rust only has one String type in the core language, which is the string slice str usually
seen in its borrowed form &str
-String slices are references to to UTF-8 encoded strings
String literals are stored in the program's binary and therefore string slices
=The String type which is provided by the Rust standard library is a growable, mutable, owned
UTF-8 encoded string type

Creating a String
=A String is actually implemented as a wrapper around a vector of bytes

//Create an empty String
let mut s = String::new(); //creation of a new empty String to load data

let data = "initial contents";

let s = data.to_string();
//the method also works on a literal directly
let s = "initial contents".to_string();

//using a function String::from to create a String from a string literal
let s = String::from("initial contents");

Updating a String
=A String can grow in size and its contents can change
In addition one can use the + operator or the format! macro to concatenate String values

Append to a String with push_str and and push
=A string can grow  by using the push_str method to append a string slice

let mut s = String::from("rust");
s.push_str("language");

=The push_str method takes a string slice since it should not take ownership of its parameter

let mut s1 = String::from("java");
let s2 = "language";
s1.push_str(s2);
println!("s2 is {s2}");

Push Method
=The Push method takes a single character as a parameter and adds it to the String

let mut  s = String::from("lo");
s.push('l');

Concatenation with the + operator or format macro!
String Concatenation
-A String value can be appended to another String
This is called concatenation or interpolation
The result of a String concatenation is a new String Object
The + operator internally uses a add method
The syntax for the add function takes two parameters. The first parameter is the String object itself and the second parameter
is a reference of the second string object

//add function
add(self, &str) -> String {
//returns a String object
}
=To combine two strings concatenation is used
:let s1 = String::from("Hello, ");
 let s2 = String::from("world!");
 let s3 = s1 + &s2; //s1 has been moved here so it is no longer valid since a reference to s2 has been
 used and also the signature of the + operator is as follows:
 fn add(self, s:&str) -> String {}
 & - adding a reference of the second string to the first string, this is because of the
 s parameter in the add fn: we can only add &string to a String and two String values cannot be addd together
NOTE: The compiler coerces the &String argument into &str, When the add method is called, Rust uses deref coercion
which turns &s2 into &s2[..]
Add method takes ownership of self because self does not have a &

Format Macro
=The format macro returns a String with its contents
=The code generated by the format macro uses references so that the call does not take ownership of its parameters
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");

Indexing Of Strings
Accessing parts of a String using the indexing syntax in Rust results in an error
let s1 = String::from("h1");
let h = s1[0];
}

A string is a wrapper of vec<u8>
Each letter in a string takes 1 byte when encoded in UTF-8, each Unicode scalar value takes 2 bytes of storage
Therefore an index into the string bytes will not always correlate to a valid Unicode scalar value
Rust does not allow to index to a String to get a character is that  indexing operations  are expected to always take
a constant time (0(1))
It is also not clear what the return type of the string indexing operation will be

Slicing Strings
=Rather than indexing using [] with a single number, one can use [] with a range to create a string slice
containing particular bytes

String Slice Operation
let hello = "Здравствуйте";
let s = &hello[0..4] //s is an &str that contains the first four bytes of the String

Slicing only a part of a character byte causes Rust to panic at runtime i.e &hello[0..1] - causes
a panic at runtime

Methods for Iterating Over Strings
=To operate on Strings one has to be explicit whether they need a characters or bytes
-For individual Unicode Scalar Values use the char method

i.e for c in "3д".chars() {
   println!("{c}");
 }
Alternatively use  the bytes method to ro return each raw byte
for b in "3д".bytes(){
  println!("{b}");
}



