=A collection is a data structure that stores multiple values, often dynamically, and provides an efficient
way to access, modify and iterate values

Core Traits of Rust Collections
I)Dynamic sizing: Most collections can grow and shrink at runtime
II)Ownership aware: They integrate seamlessly with Rust ownership and borrow rules
III)Type safe: Collections are type-safe, generic allowing one to specify types of
elements they hold
IV)Memory-safe: Rust ensures no invalid memory access even with complex operations

Collection Types
Type                              Description                               Uses
I)Vec<T>                          Growable array                            Storing a list of Items in Order

II)HashMap<K, V>                  Key-value store                           Caching, Indexing, associative data
                                  with fast retrieval

III)HashSet<T>                    Unordered set of unique                   Tracking seen items, deduplication
                                  values

IV)LinkedList<T>                  Doubly-linked list                        Efficient insertions/removal at the middle of
                                                                            the collection

V)VecDeque<T>                     Double ended Queue                        Queue principle(Fast-In-First-Out)

vi)BTreeMap<K,V>                  Sorted key-value collection               Range queries, ordered iterations

vii)BinaryHeap<T>                 PriorityQueue                             Task Scheduling max and min retrieval

Collections are grouped into
-Sequences: ordered lists e.c Vec, VecDeque, LinkedList
-Map: key-value stores (HashMap, BTreeMap)
-Sets: Unique unordered  value(HashSet, BTreeSet)

-------------------------------------------------------------------------------------------------------------------------
Storing a List of Vales using vectors
=Vec<T> is also known as Vector. The Use of vectors allow one to store more than one value in a single data structure
that puts all the values next to each other in Memory
=Vectors can only store values of the same type

Creating a new Empty Vector
=To create a new empty vector one calls the function Vec::new()
*let v: Vec<i32> = Vec::new(); //Vec<T> holds elements of i32 type
=Type annotation is added to Vectors since they implement Generics
Vec<T> provided by the library can hold any type. When one creates a vector to hold a specific type, the type is specified
within the < > brackets

Vector Macro
The vec! macro is used to create a vector that holds values given to it
*let v = vec![1, 2, 3, 4, 5]; //the integer type is i32(default integer type)
Rust can infer that the type of vector v is Vec<i32> and type annotation is not necessary

Updating a Vector
To create a vector and then add elements to it use the push method

let mut v = Vec::new();
v.push(100);
v.push(200);
v.push(300);
v.push(400);
v.push(500);
=As with any variable if one wants to be able to change its value, it must be made mutable using the mut
keyword
=The numbers placed inside are of type i32, Rust infers that from the data hence annotation is unnecessary

Reading Elements of Vectors
=There are two ways to reference a value stored in a vector, via indexing or using the get method

let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
 Some(third) => println!("Thw third element is {third}");
 None => println!("There is no third element");
 }

 NOTE: We use an index of 2 to get the third element because vectors are indexed by numbers, starting
 at zero. Using & and [] gives a reference to the element at the index value
 When one uses get method with the index passed as an argument, we get an Option<&T> that
 can be used with match

 Index out of Bound
 let v = vec![1, 2, 3, 4, 5];

 let does_not_exist = &v[100];
 let does _not_exist = v.get(100);

 The first [] method causes the program to panic because it references anon existent element
 When the get method is passed an index that is outside the vector, it returns none without panicking

 When a program has a valid reference,  the borrow checker enforces ownership and borrow rules
 to ensure that references to items always remain valid
 NOTE: One cannot have an immutable and mutable reference in the same scope
 Vectors  put values next to each other in memory, adding a new element onto the end of the vector might require
 allocating new memory and copying the elements to the new space. If there is no room enough to put all the
 elements next to each other where the vector is currently stored. In that case, the reference to the first element
 would be pointing to a deallocated memory

 i.e
 let mut v = vec![100, 200, 300, 400, 500];

 let first = &v[0]; //immutable borrow

 v.push(6); //mutable borrow

 println!("The first element is: {first}");

 Iterating over values in a vector
 =To access each element in a vector in turn, iterate through all the elements rather than use indices to access one
 at a time

 //for loop to get immutable references to each element in a vector of i32 and print them
 let v = vec![100, 32. 57];

 for i in &v{
  println!("{i}");
}

//One can also iterate over mutable references to each element in the mutable vector

let mut v = vec![100, 32 57];

for i in &mut v {
 *i += 50;
 }

To change the value that the mutable reference refers to use the * operator  to get to the value in i

NOTE: Rust knows what types are stored in a vector at compile time, so it knows  exactly how much memory
on the heap is needed to store each element

Dropping items in a vector
=A vector is freed when it goes out of scope
   {
   let v = vec![100, 200, 300, 400, 500];
   //manipulate v
   }
When the vector gets dropped , all of its contents are also dropped, meaning that the integers it holds will be cleaned up
The borrow checker ensures that any references to the contents of a vector are only used  while the vector itself is valid
-------------------------------------------------------------------------------------------------------------------------------

HashMap
=The type HashMap<K, V> stores a mapping of keys of type K, to values of type V using hashing function, which determines how
it places these keys and values in memory
=HashMaps are useful when one wants to look up to data by using a key that can be of any type

Creating a HashMap
=One way to create an empty HashMap is to use new and to add elements with insert

HashMaps store their data on the heap. This hash map has a key of type String and value of type i32
HashMaps are also homogenous, all of the keys must have the same type, and all the values must
have the same type

Accessing a value in a HashMap
One can get a value out of a hash map by providing a key to the get method

Iterating over a HashMap
=One can iterate over each key-value pair in a hash map similar to a vector using a for loop

HashMaps and Ownerships
=For types that implement the copy trait, like i32 the values are copied into the hash map
For owned values like String, the values will be moved and the hash map will be the owner of those values

use std::collections::HashMap;

let field_name = String::from("Favorite Color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
//field_name and field_value are invalid at this point since they have been moved into the hash map
=If we insert references to values in the hash map, the values won't be moved into the hash map
The values that the references point to must be valid for at least as long as the hash map is valid

Updating a HashMap
Overwriting  value
=If one inserts a key and a value into a hash map and then insert that same key again with a different value, the
value associated with that key will be replaced

Adding a key and a value only if it is not present
=If the key does exist in the hash map, the existing value should remain the way it is ,
if it does not exist, insert it  and a value for it

HashMap use an API called entry that takes a key one wants to check as a parameter
The return value of the entry method is an Enum called entry that represents a value that
might not exist or might exist

The or_insert method on Entry is defined to return a mutable reference to the value for the corresponding
Entry Key if that key exists, and if not, it inserts the parameter as a new value for this key and returns
a mutable reference to the value

Hashing Functions
=By Default, a HashMap uses a hashing function that is referred to SipHash that can provide resistance to
denial of service attacks involving HashTables
=A Hasher is a type that implements the BuildHasher Trait





