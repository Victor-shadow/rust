=Interior mutability is a design pattern in Rust that allows one to mutate data even when there are
immutable references to the data
Normally this action is disallowed by the borrow rules, To mutate data the pattern uses unsafe code
inside a data structure to  bend Rust usual Rules that govern mutation and borrowing
=Unsafe code indicates to the compiler that rules are being checked manually instead of relying on the compiler
to check the rules

=One can  use the types that use the interior mutability pattern only when we can ensure that
the borrowing rules will be followed at runtime, even though the compiler cannot guarantee that
=The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable


Enforce Borrowing Rules at Runtime with RefCell<T>
-Unlike Rc<T>, RefCell<T> type represents a single ownership over the data it holds
Borrow rules include:
i)At any given time, you can either have one mutable reference or ay number of immutable
reference(but not both)
ii)references must always be valid

With references and Box<T>, the borrowing rules invariants are enforced at compile time. With RefCell<T>,
these invariants are enforced at runtime. With references, if the rules are broken, a compiler error is achieved
With RefCell<T>, if the rules are broken, the program panics and exits
The advantages of checking the borrowing rules at runtime, are that errors are caught sooner in the development process
and there is no impact on runtime performance because all the analysis is completed before hand

The advantage of checking the borrowing rules also is that  certain memory-safe scenarios are then allowed, which would be by then
disallowed by the compile time checks
Static analysis like the Rust compiler, is inherently conservative
The RefCell<T> type is useful when the code follows the borrowing rules but the compiler is unable
to understand and guarantee that
=Similar to Rc<T> , RefCell<T> is only for use in single-threaded scenarios and can give one
a compile-time error if one tries to use it in a multi-threaded context

Note: Here are the Reasons to choose Box<T>, Rc<T>, RefCell<T>:
I)Rc<T> enables multiple owners of the same data, Box<T> and RefCell<T> have single
owners
II)Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> only allows
immutable borrows checked at compile time, RefCell<T> allows immutable or mutable borrows
checked at runtime
III)Since RefCell<T> allows mutable references checked at runtime, one can mutate the value inside the RefCell<T> even when
it is immutable

Mutating the value inside the Immutable value is an interior Mutability Pattern

Interior Mutability
=A consequence of the borrow rule is that  when one has an immutable value, one cannot borrow it
mutably

fn main(){
   let x = 5;
   let y = &mut x;
}
NOTE: However, there are situations in which it would be useful for a value to mutate itself in its method
but appear immutable in the code
Code outside the value method would not be able to mutate the value
Using RefCell<T> is one way to get the ability to have interior mutability, but RefCell<T>
does not get around the borrowing rules completely;  the borrow checker in the compiler allows
interior mutability, and the borrowing rules can be checked at runtime instead
If the rules are violated one gets a panic! instead of a compiler error

Use case for Interior Mutability
-During testing one can use a type in place of another type in order to observe a particular
behaviour and assert that it has been implemented correctly
This placeholder type is called a test double,(they stand in for other types when tests are run)
Mock objects are specific types of test doubles that record what happens during a test, so one can
assert that the correct actions took place

NOTE:
When creating immutable and mutable references, use the & and &mut syntax
With RefCell<T> one can use the borrow and borrow_mut methods which is part of the safe API that belongs to the
RefCell<T>. The borrow method returns the smart pointer type Ref<T> and borrow_mut returns  the smart pointer type
RefMut<T>. Both types implement the Deref trait, so they can be treated as regular references

The RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active
Every time borrow is called the RefCell<T> increases its count of how many immutable borrows are active
When Ref<T> value goes out of scope, the count of the immutable borrow goes down by 1
NOTE: RefCell<T> lets one have many immutable borrows or one mutable borrow at a time

Allowing Multiple Owners of Mutable Data with Rc<T> and RefCell<T>
-Rc<T> allows one to have multiple owners of the same data, but it only gives immutable access to that data
If one has Rc<T> that holds a RefCell<T> one can get a value that has multiple owners and that one can mutate

NOTE:Using RefCell<T> makes it possible to write a mock object that can modify itself

NOTE: Creating two mutable borrows with the implementation of RefCell<T>  causes panic at runtime
impl Messenger for MockMessenger {
    fn send(&self, message: &str){
         let mut one_borrow = self.sent_messages.borrow_mut();
         let mut two_borrow = self.sent_messages.borrow_mut();

         one_borrow.push(String::from(message));
         two_borrow.push(String::from(message));
    }
}
We create a variable one_borrow for the RefMut<T> smart pointer returned from borrow_mut
Then another mutable borrow is created in the same way through two_borrow
This makes two mutable borrows in the same scope, which is not allowed by rust