=The iterator pattern allows one to perform some task on a sequence of items in turn
An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished
=In Rust, iterators are lazy meaning they do not have any effect until you call methods that consume
the iterators to use it up

//An iterator over the items in the vector v1 by calling iter method defined in Vec<T>

let v1 = vec![1, 2 3];
let v2 = v1.iter();

The Iterator is stored in the v2 variable. Once, one has created an iterator it can be used in a variety of ways
NOTE: When the for loop is called using the iterator in v2, each element in the iterator is used in one iteration
of the loop, which prints out the value

let v1 = vec![1, 2, 3];
let v2 = v1.iter();
for val in v2 {
  println!("Got: {val}");
}

=Iterators give one more flexibility to use the same logic with different kind of sequences, not just data structures
you can index into, like vectors

Iterator Trait and Next method
=All iterators implement a trait named Iterator that is defined in the Standard Library
=The Iterator trait:
  pub  trait Iterator {
     type Item;

     fn next(&mut self) -> Option<Self::Item>;
     //methods with default implementation elided
  }
=The definition uses some new syntax: type Item and Self::Item, which are defining an associated type with this trait
NOTE: Implementing the Iterator trait requires that  you also define an Item type, and this Item type is used in the return type
of the next method(The Item type will be the type returned from the iterator)
=The Iterator trait only requires implementors  to define one method: the next method which returns one item of the
iterator at a time, wrapped in Some and when the iteration is over, it returns None
=We can call the next method on iterators directly

fn main(){
    let v1 = vec![1, 2, 3, 4];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), Some(&4));
    assert_eq!(v1_iter.next(), None);
}
//Note: v1_iter needs to be made mutable; calling next method on an iterator changes the internal state
//that the iterator uses to keep track of where it is in the sequence
//This code consumes or uses up the iterator, Each call to the next eats up an item from the iterator
//We did not need to make v1_iter mutable  then a for loop is used, because the loop took ownership of the v1_iter  and made it mutable

//Also note that the values we get from calls to next are immutable references to the values in the vector
//The iter method produces the iterator over immutable references
//If one wants to create an iterator that takes ownership of v1 and returns owned values  we can call into_iter method instead
//If One wants  to iterate over mutable references, we can call iter_mut instead

------------------------------------------------------------------------------------------------------------------------
METHODS THAT CONSUME THE ITERATOR
=The Iterator trait  has a number of different methods with default implementations provided by the
standard library
=Some of these methods  call the next method in their definition, which is why one is required to implement the
next method when implementing the Iterator trait

Methods that call next are consuming adapters because calling them uses up an iterator
The sum method takes ownership of the iterator and iterates through the items repeatedly by calling next,
thus consuming the iterator. As it iterates through, it adds each item to a running total and returns the total
when the iteration is complete

#[test]
fn iterator_sum(){
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();
     assert_eq!(total, 6);
}
We are not allowed to use v1_iter after the call to sum because sum takes ownership of the iterator we call it on
------------------------------------------------------------------------------------------------------------------------

Methods that produce Other Iterators
=Iterator adapters are methods defined on the Iterator trait that do not consume the Iterator
Instead, they produce different Iterators by changing some aspect of the Original Iterator
=The Iterator adapter map takes a closure to call on each item as the items are iterated through
The map method returns a new Iterator that produces the modified items

let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);

The closure specified never gets called. The compiler warning reminds one why iterator adapters are lazy
and the iterators need to be consumed
To fix this warning and consume the iterator use the collect method, This method consumes the iterator and
collects the resultant value into a collection data type
NOTE: One can chain multiple calls to iterator adapters to perform complex operations in a readable way
Because all iterators are lazy, one has to call one of the consuming adapter methods to get results from calls to
iterator adapters

Using Closures that Capture Environment
Many Iterator adapters take closures as arguments, and commonly the closures we  will specify as arguments
to iterator adapters will be closures that capture their environment
The filter method  that takes a closure, the closure gets an item from an iterator and returns a bool, If the closure returns true,
the value will be included in the iteration produced by the filter. If the closure returns false, the value won't be included

------------------------------------------------------------------------------------------------------------------------------
#[derive(PartialEq, Debug)]
struct Shoe {
  size: u32,
  style: String,
}
fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
   shoes.into_iter().filter(|s| s.size == shoe.size).collect()
}

#[cfg(test)]
mod tests {
   use super::*;

   #[test]
   fn filters_by_size(){
       let shoes = vec![
          Shoe {
            size: 10,
            style: String::from("sneaker"),
          },
          Shoe {
           size: 13,
           style: String::from("sandal"),
         },
         Shoe {
           size: 10,
           style: String::from("boot"),
           },
          ];

       let in_my_size= shoes_in_size(shoes, 10);

       assert_eq!(
        in_my_size,
        vec![
        Shoe {
          size: 10,
          style: String::from("sneaker"),
          },
          Shoe {
          size: 10,
          style: String::from("boot")
          },
      ]
   );
 }
}
------------------------------------------------------------------------------------------------------------------------

The shoes_in_size function takes ownership of a vector of shoes and a shoe size as a parameter
It returns a vector containing only shoes of the specified size
In the body of shoes_in_size, call into_iter to create an iterator that takes ownership of the vector
Then call filter to adapt the iterator into a new iterator that contains only elements for which the closure
returns true
The closure captures the shoe size parameter from the environment and compares the values with each shoe size
keeping only shoes of the size specified. Finally, calling collect gathers the values returned by the adapted iterator into a vector
that is returned by the function